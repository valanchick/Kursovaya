# Описание

Игра "Жизнь" — это клеточный автомат, придуманный математиком Джоном Конвеем в 1970 году. Программа включает три режима симуляции:

1. **Классическая игра Жизни** — черно-белые клетки с базовыми правилами.
2. **Цветная игра Жизни** — клетки могут иметь любой цвет, который наследуется от соседей.
3. **Шахматная игра Жизни** — клетки бывают белыми или черными, со своими правилами выживания.

## Особенности режимов

### Классический режим
- Клетки могут быть либо живыми (черные), либо мертвыми (серые).
- Доступны предустановленные паттерны (Block, Glider, Eight).

### Цветной режим
- Клетки могут быть любого цвета.
- Цвет новых клеток определяется как средний цвет соседей.
- Можно задавать цвет новых клеток в формате RGB (например, "255,0,0" для красного).

### Шахматный режим
- Клетки могут быть белыми, черными или мертвыми (серые).
- Подсчитывается количество белых и черных клеток.
- Режим завершается, когда остаются клетки только одного цвета или все клетки умирают.

## Правила игры

### Классический режим
- **Выживание**: Клетка остается живой, если у нее 2 или 3 живых соседа.
- **Гибель**: Клетка умирает, если соседей меньше 2 (одиночество) или больше 3 (перенаселение).
- **Рождение**: Мертвая клетка оживает, если у нее ровно 3 живых соседа.

### Цветной режим
- **Выживание**: Клетка остается живой, если у нее 2 или 3 живых соседа. Цвет сохраняется.
- **Гибель**: Клетка умирает, если соседей меньше 2 или больше 3.
- **Рождение**: Мертвая клетка оживает, если у нее ровно 3 живых соседа. Цвет определяется как средний цвет соседей.

### Шахматный режим
- **Белые клетки**: Остаются живыми при 2 или 3 белых соседях, рождаются при 3 белых соседях.
- **Черные клетки**: Остаются живыми при 2 или 3 черных соседях, рождаются при 3 черных соседях.
- **Гибель**: Любая клетка умирает, если соседей меньше 2 или больше 3.

## Актуальность
Данное ПО позволяет автоматизировать и ускорить создание симуляций при разных конфигурационных данных. Также ПО позволяет удобно создавать начальные настройки.

---

# Спецификация

## Функциональные требования

### Функции:
- Принятие на обработку двух целочисленных значений (ширина и высота поля).
- Создание окна соответствующего размера на основе введённых пользователем данных.
- Задание состояния каждой ячейки (живая/мёртвая) через интерактивное взаимодействие:
  - Чётное количество нажатий — клетка мертва (не закрашена).
  - Нечётное количество нажатий — клетка жива (закрашена).
- Определение последующего состояния клеток по правилам игры:
  - Классическая версия: правила Conway's Game of Life.
  - Цветная версия: правила с учётом цвета соседей.
  - Шахматная версия: правила для белых и чёрных клеток.
- Изменение состояния клеток при каждом шаге симуляции.
- Управление симуляцией:
  - Запуск/остановка симуляции кнопкой или клавишей.
  - Остановка симуляции при вымирании всех клеток.
- Отображение правил игры в отдельном окне с помощью нажатия кнопки или клавиши.
- Подсчёт поколений и отображение их количества.
- Изменение интерфейса при завершении симуляции (окно с сообщением).

### Входные данные:
- Ширина поля: целое число в диапазоне [1; 150]. Обязательное поле. Ошибочные значения не принимаются.
- Высота поля: целое число в диапазоне [1; 150]. Обязательное поле. Ошибочные значения не принимаются.
- Состояние ячеек: интерактивное задание через клики мыши. Необязательное поле.
- Управление симуляцией:
  - Кнопки интерфейса.
  - Пробел: запуск/остановка симуляции.
  - Q: отображение правил игры.

### Выходные данные:
- Графическое представление поля с клетками.
- Текстовое сообщение о номере поколения.
- Окно с сообщением "Симуляция окончена" при завершении.

### Пользовательский интерфейс:
- Начальное окно с выбором модификации симуляции.
- Начальное окно с полями ввода ширины и высоты.
- Подсказки над полями ввода: "Введите количество ячеек в ширину/длину".
- Основное окно с полем клеток и панелью управления:
  - Кнопки: "Start/Stop", "Clear", "Rules", "Music".
  - Слайдер для регулировки скорости симуляции.
  - Отображение поколения и количества живых клеток.
- Окно с правилами игры.
- Окно завершения симуляции.

### Сценарии использования:
1. Пользователь выбирает тип симуляции.
2. Пользователь задаёт размеры поля и стартовую конфигурацию.
3. Запускает симуляцию и наблюдает за эволюцией клеток.
4. Останавливает симуляцию или выходит из программы.

### Ограничения:
- Ввод только целых чисел в диапазоне [1; 150].
- Запуск симуляции возможен только после задания размеров поля.

### Зависимости:
- Для работы программы требуется библиотека SFML.
- Корректный ввод данных пользователем.

## Нефункциональные требования
1. **Производительность**: Время отклика на действия пользователя не должно превышать 2 секунды.
2. **Надёжность**: Доступность программы — не менее 99.9% времени.
3. **Безопасность**: Проверка вводимых данных на корректность.
4. **Удобство использования**: 99.9% пользователей должны успешно выполнить задачу с первой попытки.
5. **Сопровождаемость**: Требования не предъявляются.
6. **Масштабируемость**: Поддержка полей размером до 150x150 клеток без значительного снижения производительности.
7. **Совместимость**: Совместимость с ПК и ноутбуками на различных ОС (Windows, Linux, macOS).
8. **Доступность**: Программа доступна для использования круглосуточно.
9. **Нормативные требования**: Соответствие стандартам ISO 9241 (интерфейс).
10. **Производительность под нагрузкой**: Стабильная работа при использовании одним пользователем.

---

# Особенности реализации

1. **Графический интерфейс**:
   - Реализован на основе библиотеки SFML.
   - Поддержка трёх режимов симуляции: классический, цветной, шахматный.
2. **Настройки поля**:
   - Размер поля настраивается от 1x1 до 150x150 клеток.
   - Автоматический расчёт размера клеток для отображения.
3. **Топология**:
   - Тороидальная (края поля соединены).
4. **Управление**:
   - Запуск/остановка симуляции кнопкой или клавишей пробела.
   - Ручное редактирование клеток кликами мыши.
5. **Визуализация**:
   - Отображение текущего состояния клеток и поколения.
   - Автоматическое завершение при вымирании всех клеток.
6. **Дополнительные функции**:
   - Выбор музыки для фона.
   - Отображение правил игры.

---

# Управление

- **Левая кнопка мыши (ЛКМ)** — используется для взаимодействия с кнопками графического интерфейса, выбора типа симуляции и изменения состояния клеток.

### Ввод размеров поля:
1. Наведите курсор на поле ввода и нажмите ЛКМ, чтобы активировать его.
2. Введите значения с клавиатуры (только цифры от 1 до 150).
3. Для подтверждения ввода нажмите **Enter**.

### Изменение состояния клетки:
Нажмите ЛКМ на клетку, чтобы изменить её состояние:
- **Классический режим**: мёртвая → живая, живая → мёртвая.
- **Цветной режим**: прозрачная → текущий цвет, текущий цвет → прозрачная.
- **Шахматный режим**: мёртвая → белая → чёрная → мёртвая.

### Запуск и остановка симуляции:
- Нажмите ЛКМ на кнопку **Start**, чтобы начать симуляцию (кнопка изменится на **Stop**).
- Нажмите ЛКМ на кнопку **Stop**, чтобы приостановить симуляцию.
- Также можно использовать клавишу **Пробел** для запуска/остановки.

### Очистка поля:
Нажмите ЛКМ на кнопку **Clear**, чтобы очистить поле и сбросить поколения.

### Изменение скорости симуляции:
Перетащите ползунок ЛКМ, чтобы выбрать скорость (1.0x, 1.5x, 1.75x, 2.0x, 2.5x). Ползунок автоматически фиксируется на ближайшем значении.

### Изменение размеров поля:
Используйте кнопки **+** и **-** для строк (Rows) и столбцов (Cols), чтобы изменить размер поля (от 1x1 до 150x150).

### Выход из программы:
Нажмите ЛКМ на крестик в правом верхнем углу окна.

---

# Ограничения начальных данных

### Размеры поля:
- Минимальный размер: 1x1 клетка.
- Максимальный размер: 150x150 клеток.
- Вводятся только цифры. Другие символы игнорируются.
- При выходе за допустимый диапазон появляется сообщение об ошибке: *"PLEASE ENTER VALUES BETWEEN 1 AND 150"*.

### Состояние клетки:
- **Классический режим**: клетка может быть живой (чёрная) или мёртвой (серая).
- **Цветной режим**: клетка может быть прозрачной (серая) или окрашенной в выбранный цвет.
- **Шахматный режим**: клетка может быть мёртвой (серая), белой или чёрной.
- Состояние клетки можно изменять неограниченное количество раз.

### Паттерны (только в классическом режиме):
- Доступны предустановленные паттерны: *Block*, *Glider*, *Eight*.
- Если поле слишком мало для выбранного паттерна, появится сообщение: *"The field is too small for this pattern"*.

---

# Требования к установке программы

Скачать exe файл проекта с Git Hub https://github.com/valanchick/Kursovaya
Скачать все сопутствующие файлы (аудио файлы, файлы библиотеки sfml и файл со шрифтом)
Поместить все файлы в одну папку, включая exe файл следующим образом
/Game/
├── Project2.exe
├── sfml-audio-2.dll
├── sfml-graphics-2.dll
├── sfml-network-2.dll
├── sfml-system-2.dll
├── sfml-window-2.dll
├── resources/
        ├── audio/
                   ├── music 1.mp3
                  ├── music 2.mp3
	      ├── music 3.mp3
        └── font/
                  └── calibri.ttf

---

# Обзор архитектуры

Программа реализована с использованием объектно-ориентированного подхода на C++ с применением библиотеки SFML для графики и аудио. Архитектура следует принципам MVC (Model-View-Controller), где:

- **Model**: Классы `GameOfLife`, `ColorGameOfLife`, `ChessGameOfLife`.
- **View**: SFML рендеринг и элементы интерфейса.
- **Controller**: Обработчики событий в главном цикле.

---

# Ключевые алгоритмы

### Алгоритм вычисления поколения (классическая версия)
1. Создание расширенной матрицы для тороидальных границ.
2. Для каждой клетки:
   - Подсчет живых соседей (8-связность).
   - Применение правил Конвея:
     - Живая клетка с 2-3 соседями → выживает.
     - Мертвая клетка с 3 соседями → оживает.
     - Иначе → умирает/остается мертвой.

### Алгоритм для цветной версии
1. Для каждой живой клетки:
   - Сбор цветов всех живых соседей.
   - Вычисление среднего цвета.
2. Применение модифицированных правил Конвея:
   - Новые клетки получают средний цвет соседей.

### Алгоритм для шахматной версии
1. Раздельный подсчет белых и черных соседей.
2. Разные правила для разных цветов:
   - Белые клетки реагируют только на белых соседей.
   - Черные клетки реагируют только на черных соседей.
3. Проверка условий победы.

---

# Оптимизация

### Оптимизация вычисления поколений
- **Расширенная матрица (тороидальные границы)**:
  - Преимущество: Устраняет необходимость проверки границ при подсчете соседей.
  - Производительность: O(1) доступ к соседям вместо сложных условий.
  - Память: Дополнительные 2 строки и 2 столбца (~4% накладных расходов для поля 50x50).

- **Локальный подсчет изменений**:
  - Позволяет быстро определить стабилизацию системы.
  - Оптимизация рендеринга (если `changes == 0`, можно пропустить некоторые обновления).

### Оптимизация памяти
- **Предварительное выделение памяти**:
  - Исключает многократные перераспределения памяти.
  - Снижает фрагментацию памяти для больших полей.

- **Использование простых типов данных**:
  - Для классической версии: `vector<vector<int>>` (1 бит на клетку было бы оптимальнее, но сложнее в реализации).
  - Для шахматной версии: `vector<vector<short>>` (2 бита на клетку).

---

# Реализованные функции

### Класс `Slider` (Ползунок скорости)
- **Назначение**: Позволяет регулировать скорость симуляции (1.0x, 1.5x, 1.75x, 2.0x, 2.5x).
- **Методы**:
  - `Slider(x, y, min, max)`: Конструктор, создаёт ползунок.
  - `handleEvent(event, window)`: Обрабатывает перемещение ползунка мышью.
  - `snapToNearestMark()`: Фиксирует ползунок на ближайшей метке.
  - `updateVisuals()`: Обновляет отображение ползунка.
  - `getValue()`: Возвращает текущее значение скорости.
  - `draw(window)`: Отрисовывает ползунок.

### Функция `chooseSimulationType(window)`
- **Назначение**: Отображает меню выбора типа симуляции (классическая, цветная, шахматная).
- **Входные данные**: Окно SFML.
- **Выходные данные**: `SimulationType` (`CLASSIC`, `COLORED`, `CHESS`, `EXIT`).

### Функция `getInput(window, screenWidth, screenHeight, size, simType)`
- **Назначение**: Позволяет пользователю ввести размеры поля (ширину и высоту).
- **Входные данные**: Окно SFML, размеры экрана, массив для сохранения размеров, тип симуляции.
- **Выходные данные**: Заполняет массив `size` (ширина и высота).

### Функция `getCellSize(cols, rows, screenWidth, screenHeight)`
- **Назначение**: Вычисляет оптимальный размер клетки, чтобы поле помещалось на экран.
- **Входные данные**: Размеры поля и экрана.
- **Выходные данные**: Размер клетки в пикселях.

### Класс `ChessGameOfLife` (Шахматный режим)
- **Назначение**: Реализует правила шахматной версии "Игры Жизни".
- **Методы**:
  - `ChessGameOfLife(rows, cols, CELL_SIZE)`: Конструктор.
  - `toggleCell(x, y)`: Переключает клетку (мёртвая → белая → чёрная → мёртвая).
  - `countLiveCells()`: Возвращает количество белых и чёрных клеток.
  - `clear()`: Очищает поле.
  - `change()`: Вычисляет следующее поколение клеток.
  - `draw(window)`: Отрисовывает поле.
  - `checkVictory()`: Проверяет условия победы.

### Класс `ColorGameOfLife` (Цветной режим)
- **Назначение**: Реализует цветную версию "Игры Жизни".
- **Методы**:
  - `ColorGameOfLife(rows, cols, CELL_SIZE)`: Конструктор.
  - `setCurrentColor(r, g, b)`: Устанавливает текущий цвет для новых клеток.
  - `toggleCell(x, y)`: Переключает клетку (прозрачная → текущий цвет → прозрачная).
  - `countLiveCells()`: Возвращает количество живых клеток.
  - `clear()`: Очищает поле.
  - `change()`: Вычисляет следующее поколение клеток.
  - `draw(window)`: Отрисовывает поле.

### Класс `GameOfLife` (Классический режим)
- **Назначение**: Реализует классические правила "Игры Жизни".
- **Методы**:
  - `GameOfLife(rows, cols, CELL_SIZE)`: Конструктор.
  - `setCell(x, y, state)`: Устанавливает состояние клетки.
  - `toggleCell(x, y)`: Переключает клетку (мёртвая → живая → мёртвая).
  - `countLiveCells()`: Возвращает количество живых клеток.
  - `clear()`: Очищает поле.
  - `change()`: Вычисляет следующее поколение клеток.
  - `draw(window)`: Отрисовывает поле.

### Класс `CellCountControl` (Управление размерами поля)
- **Назначение**: Позволяет изменять количество строк и столбцов в поле.
- **Методы**:
  - `CellCountControl(x, y, initialRows, initialCols, min, max, font)`: Конструктор.
  - `handleEvent(event, window)`: Обрабатывает нажатия кнопок "+" и "-".
  - `draw(window)`: Отрисовывает элементы управления.
  - `getRows()`, `getCols()`: Возвращает текущие размеры поля.

### Главная функция `main()`
- **Назначение**: Управляет всей программой, создаёт окна, обрабатывает события.
- **Основные этапы работы**:
  1. Загрузка шрифтов и музыки.
  2. Выбор типа симуляции (`chooseSimulationType`).
  3. Ввод размеров поля (`getInput`).
  4. Создание окна и инициализация выбранного режима.
  5. Обработка событий:
     - Запуск/остановка симуляции.
     - Изменение скорости (`Slider`).
     - Изменение размеров поля (`CellCountControl`).
     - Очистка поля.
  6. Отрисовка интерфейса и поля.
